#if defined(macintosh)
#include <types.h>
#else
#include <sys/types.h>
#endif
#include <stdio.h>
#include <string.h>
#include "merc.h"
#include "tables.h"

DECLARE_DO_FUN(do_drop);
DECLARE_DO_FUN(do_sacrifice);

// local function declarations
char*	ctos	args((long *coins, bool full_str));

// local variable declarations
static long *coin_array;
static char coin_str[MAX_STRING_LENGTH];

char* value_to_str(float value)
{
    return ctos(value_to_coins(value, FALSE), TRUE);
}

char *value_to_sstr(float value)
{
    return ctos(value_to_coins(value, FALSE), FALSE);
}

char* coins_to_str(long *coins)
{
    return ctos(coins, TRUE);
}

char *coins_to_sstr(long *coins)
{
    return ctos(coins, FALSE);
}

char* ctos(long *coins, bool full_str)
{
    bool first = TRUE;
    int i;
    char buf[MAX_STRING_LENGTH];

    memset((void *) coin_str, 0, MAX_STRING_LENGTH);

    for (i = 0; i < MAX_COIN; i++)
	if (coins[i] > 0)
	{
	    if (full_str)
	        sprintf(buf, "%s%ld %s", first ? "" : ", ",  coins[i], coin_table[i].name);
	    else
		sprintf(buf, "%s%ld%s", first ? "" : " ", coins[i], coin_table[i].abbr);

	    strcat(coin_str, buf);
	    first = FALSE;
	}

    if (coin_str[0] == '\0')
	strcpy(coin_str, "no coins");

    return coin_str;
}
	

float coins_to_value(long *coins)
{
    float value = 0;
    int i;

    for (i = 0; i < MAX_COIN; i++)
	value += coin_table[i].value * coins[i];

    return value;
}

// takes a certain value of coins and converts it into an array of the appropriate types
long* value_to_coins(float value, bool fuzzy)
{
    int i, j;
    long k;

    if (!coin_array)
    {
	coin_array = (long *)malloc(MAX_COIN * sizeof(long));
	g_num_coin_array++;
    }


    for (i = 0; i < MAX_COIN; i++)
	coin_array[i] = 0;

    for (i = 0; i < MAX_COIN; i++)
    {
	if ((k = (long) (value / coin_table[i].value)) >= 1)
	{
	    coin_array[i] += k;
	    value -= k * coin_table[i].value;
	}

	for (j = i + 1; j < MAX_COIN; j++)
	    if ((coin_table[i].value < coin_table[j].value)
	     && ((k = (long)(coin_array[i] * coin_table[i].value / coin_table[j].value)) >= 1))
	    {
		coin_array[i] -= (long) (k * coin_table[j].value / coin_table[i].value);
		coin_array[j] += k;
	    }
    }

    return coin_array;	
}

// coins must be a pointer to an array of size [MAX_COIN]
// typically will be generated by value_to_coins

void inc_player_coins(CHAR_DATA *ch, long *coins)
{
    int i;

    for (i = 0; i < MAX_COIN; i++)
	coins_to_char(ch, coins[i], i);

    return;
}

bool dec_player_coins(CHAR_DATA *ch, long *coins)
{
    return coins_from_coinpool(coins, ch->coins);
}

bool dec_player_bank(CHAR_DATA *ch, long *coins)
{
    return coins_from_coinpool(coins, ch->bank);
}

void coins_to_char(CHAR_DATA *ch, long coins, int ctype)
{
    char buf[MAX_STRING_LENGTH];

    ch->coins[ctype] += coins;

    if ((ch->coins[ctype] > 0) && is_affected(ch, gsn_cursekhamurn))
    {
	send_to_char("The will of Khamurn overtakes you...\n\r", ch);
	sprintf(buf, "%ld %s", ch->coins[ctype], coin_table[ctype].name);
	do_drop(ch, buf);
	strcpy(buf, coin_table[ctype].name);
	do_sacrifice(ch, buf);
    }

    if (ch->coins[ctype] < 0)
	ch->coins[ctype] = 0;

    return;
}

void coins_from_char(CHAR_DATA *ch, long coins, int ctype)
{
    coins_to_char(ch, coins * -1, ctype);
    return;
}

long* convert_coins(long *coins)
{
    float tvalue = coins_to_value(coins);
    return value_to_coins(tvalue, FALSE);
}

bool coins_from_coinpool(long *coins, long *coinpool)
{
    int i = 0;
    long lval = -1, cval = -1, used;
    float tvalue = 0;
    long process[MAX_COIN] = {0, 0, 0, 0};

    if (coins_to_value(coins) > coins_to_value(coinpool))
	return FALSE;

    for (i = 0; i < MAX_COIN; i++)
    {
	if (coins[i] <= coinpool[i])
	{
	    coinpool[i] -= coins[i];
	    process[i] = 0;
	}
	else
	{
	    process[i] = coins[i] - coinpool[i];
	    coinpool[i] = 0;
	}
    }

    tvalue = coins_to_value(process);

    while (tvalue > 0)
    {
	for (i = 0; i < MAX_COIN; i++)
	    if ((coinpool[i] > 0)
	     && ((lval == -1) || (coin_table[i].value > coin_table[lval].value))
	     && ((cval == -1) || (coin_table[i].value < coin_table[cval].value)))
		cval = i;

	if ((coin_table[cval].value * coinpool[cval]) >= tvalue)
	{
	    used = (long) (tvalue / coin_table[cval].value);
	    coinpool[cval] -= used;
	    tvalue -= (used * coin_table[cval].value);

	    if (tvalue > 0)
	    {
		coinpool[cval] -= 1;
		tvalue -= coin_table[cval].value;
		value_to_coins(tvalue * -1, FALSE);

		for (i = 0; i < MAX_COIN; i++)
		    coinpool[i] += coin_array[i];

	    }

	    return TRUE;
	}
	else
	{
	    tvalue -= (coinpool[cval] * coin_table[cval].value);
	    coinpool[cval] = 0;
	}

	lval = cval;
	cval = -1;
    }

    return TRUE;
}
	
